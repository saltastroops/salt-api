pipeline {
  agent any

  environment {
    ENV_FILE = credentials('salt-api-dev-env')
  }

  stages {
    stage("Build the Docker image") {
      steps {
        script {
          dockerImage = docker.build("salt-api:dev")
        }
      }
    }
    stage("Push the Docker image") {
      steps {
        script {
          docker.withRegistry("${DOCKER_REGISTRY}", "docker-registry-credentials") {
            dockerImage.push()
          }
        }
      }
    }
    stage("Deploy the image and restart the server") {
      steps {
        script {
          def compose_file = sh returnStdout: true, script: 'bash jenkins/dev-deployment/prepare_docker_compose.sh'
          withCredentials(
                  [sshUserPrivateKey(credentialsId: 'salt-api-dev-server-credentials', keyFileVariable: 'identity',
                                     usernameVariable: 'username')]) {
            // Define the remote connection parameters
            def remote = [:]
            remote.name = "${SALT_API_DEV_HOST}"
            remote.host = "${SALT_API_DEV_HOST}"
            remote.allowAnyHosts = true
            remote.user = username
            remote.identityFile = identity

            // Create the necessary remote directory. The -p flag is used to avoid an
            // error if the directory exists already.
            sshCommand remote: remote, command: 'mkdir -p salt-api'

            // Prepare the docker compose file,
            def a = sh returnStdout: true, script: 'bash jenkins/dev-deployment/prepare_docker_compose.sh'
            echo "$a"

            // Copy the required files.
            sh "cat $a"
            sshPut remote: remote, from: "$a", into: 'salt-api/docker-compose.yml'
            sshPut remote: remote, from: "$ENV_FILE", into: 'salt-api/.env'

            // Update and restart the server.
          }
        }
      }
    }
  }
}
